"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCurl = void 0;
/* eslint-disable @typescript-eslint/no-this-alias */
const stream_1 = require("stream");
const Headers_js_1 = require("./Headers.js");
const Response_js_1 = require("./Response.js");
const utils_js_1 = require("./utils.js");
async function fetchCurl(fetchRequest) {
    const nodeReadable = (fetchRequest.body != null
        ? 'pipe' in fetchRequest.body
            ? fetchRequest.body
            : stream_1.Readable.from(fetchRequest.body)
        : null);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlyHeaders = headersSerializer(fetchRequest.headers, value => {
        size = Number(value);
    });
    let easyNativeBinding;
    const curlyOptions = {
        sslVerifyPeer: false,
        // we want the unparsed binary response to be returned as a stream to us
        curlyStreamResponse: true,
        curlyResponseBodyParser: false,
        curlyProgressCallback() {
            if (easyNativeBinding == null) {
                easyNativeBinding = this;
            }
            return fetchRequest['_signal']?.aborted ? 1 : 0;
        },
        upload: nodeReadable != null,
        transferEncoding: false,
        httpTransferDecoding: true,
        followLocation: fetchRequest.redirect === 'follow',
        maxRedirs: 20,
        acceptEncoding: '',
        curlyStreamUpload: nodeReadable,
        // this will just make libcurl use their own progress function (which is pretty neat)
        // curlyProgressCallback() { return CurlProgressFunc.Continue },
        // verbose: true,
        httpHeader: curlyHeaders,
        customRequest: fetchRequest.method,
    };
    if (size != null) {
        curlyOptions.inFileSize = size;
    }
    const { curly, CurlCode, CurlPause } = globalThis['libcurl'];
    if (fetchRequest['_signal']) {
        fetchRequest['_signal'].onabort = () => {
            if (easyNativeBinding != null) {
                easyNativeBinding.pause(CurlPause.Recv);
            }
        };
    }
    const curlyResult = await curly(fetchRequest.url, curlyOptions);
    const responseHeaders = new Headers_js_1.PonyfillHeaders();
    curlyResult.headers.forEach(headerInfo => {
        for (const key in headerInfo) {
            if (key === 'location' || (key === 'Location' && fetchRequest.redirect === 'error')) {
                throw new Error('redirects are not allowed');
            }
            if (key !== 'result') {
                responseHeaders.append(key, headerInfo[key]);
            }
        }
    });
    curlyResult.data.on('error', (err) => {
        if (err.isCurlError && err.code === CurlCode.CURLE_ABORTED_BY_CALLBACK) {
            // this is expected
        }
        else {
            throw err;
        }
    });
    return new Response_js_1.PonyfillResponse(curlyResult.data, {
        status: curlyResult.statusCode,
        headers: responseHeaders,
        url: fetchRequest.url,
    });
}
exports.fetchCurl = fetchCurl;
